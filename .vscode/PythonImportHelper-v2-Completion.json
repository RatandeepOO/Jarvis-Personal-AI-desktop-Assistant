[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "smtplib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "smtplib",
        "description": "smtplib",
        "detail": "smtplib",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "language_tool_python",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "language_tool_python",
        "description": "language_tool_python",
        "detail": "language_tool_python",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "pyaudio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyaudio",
        "description": "pyaudio",
        "detail": "pyaudio",
        "documentation": {}
    },
    {
        "label": "AutoModelForQuestionAnswering",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "vosk",
        "description": "vosk",
        "isExtraImport": true,
        "detail": "vosk",
        "documentation": {}
    },
    {
        "label": "KaldiRecognizer",
        "importPath": "vosk",
        "description": "vosk",
        "isExtraImport": true,
        "detail": "vosk",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "vosk",
        "description": "vosk",
        "isExtraImport": true,
        "detail": "vosk",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "googletrans",
        "description": "googletrans",
        "isExtraImport": true,
        "detail": "googletrans",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "test",
        "description": "test",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "QtCore",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtWidgets",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QtGui",
        "importPath": "PyQt5",
        "description": "PyQt5",
        "isExtraImport": true,
        "detail": "PyQt5",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QLabel",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QGraphicsDropShadowEffect",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QLabel",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QGraphicsDropShadowEffect",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QTimer",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QTimer",
        "importPath": "PyQt5.QtCore",
        "description": "PyQt5.QtCore",
        "isExtraImport": true,
        "detail": "PyQt5.QtCore",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPalette",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QColor",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPalette",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QBrush",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "QPixmap",
        "importPath": "PyQt5.QtGui",
        "description": "PyQt5.QtGui",
        "isExtraImport": true,
        "detail": "PyQt5.QtGui",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "speech_recognition",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speech_recognition",
        "description": "speech_recognition",
        "detail": "speech_recognition",
        "documentation": {}
    },
    {
        "label": "pywhatkit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pywhatkit",
        "description": "pywhatkit",
        "detail": "pywhatkit",
        "documentation": {}
    },
    {
        "label": "pyautogui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyautogui",
        "description": "pyautogui",
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "subprocess,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess.",
        "description": "subprocess.",
        "detail": "subprocess.",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n        like file_created to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location):\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(f'Path \"{location}\" does not exist!')\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python pywin32_postinstall.py -install",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python pywin32_postinstall.py -install\n    If you installed pywin32 via a .exe installer, this should be run\n    automatically after installation, but if it fails you can run it again.\n    If you installed pywin32 via PIP, you almost certainly need to run this to\n    setup the environment correctly.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(os.path.join(tempfile.gettempdir(), \"pywin32_postinstall.log\"), \"w\")\nclass Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to PythonXX\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to PythonXX\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created  # type: ignore[used-before-def]\n    # 3.10 stopped supporting bdist_wininst, but we can still build them with 3.9.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to PythonXX\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created  # type: ignore[used-before-def]\n    # 3.10 stopped supporting bdist_wininst, but we can still build them with 3.9.\n    # This can be kept until Python 3.9 or exe installers support is dropped.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [this_dir] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "this_dir",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "this_dir = os.path.dirname(__file__)\nsite_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "Assistant",
        "kind": 6,
        "importPath": "FINAL.MAIN FILE",
        "description": "FINAL.MAIN FILE",
        "peekOfCode": "class Assistant:\n    def __init__(self):\n        # Initialize the text-to-speech engine\n        self.assistant = pyttsx3.init('sapi5')\n        voices = self.assistant.getProperty('voices')\n        self.assistant.setProperty('voice', voices[1].id)\n        self.assistant.setProperty('rate', 150)\n        # Initialize the Vosk speech recognition model\n        self.vosk_models = {\n            \"english\": Model(\"FINAL\\\\Models\\\\vosk-model-small-en-in-0.4\"),",
        "detail": "FINAL.MAIN FILE",
        "documentation": {}
    },
    {
        "label": "GifLoaderWorker",
        "kind": 6,
        "importPath": "FINAL.MAIN",
        "description": "FINAL.MAIN",
        "peekOfCode": "class GifLoaderWorker(QtCore.QThread):\n    gif_path_loaded = QtCore.pyqtSignal(str)  # Signal to emit when a GIF path is loaded\n    def __init__(self, gif_paths):\n        super().__init__()\n        self.gif_paths = gif_paths\n    def run(self):\n        # Emit paths to load GIFs one by one\n        for path in self.gif_paths:\n            self.gif_path_loaded.emit(path)\n            self.msleep(100)  # Simulate a small delay for better visual understanding",
        "detail": "FINAL.MAIN",
        "documentation": {}
    },
    {
        "label": "PersonalAssistantUI",
        "kind": 6,
        "importPath": "FINAL.MAIN",
        "description": "FINAL.MAIN",
        "peekOfCode": "class PersonalAssistantUI(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n        # Set window properties\n        self.setWindowTitle(\"Personal Assistant\")\n        self.setGeometry(100, 100, 800, 600)\n        # Remove the maximize option\n        self.setWindowFlags(self.windowFlags() & ~QtCore.Qt.WindowMaximizeButtonHint)\n        # Set background color\n        self.setStyleSheet(\"background-color: black;\")",
        "detail": "FINAL.MAIN",
        "documentation": {}
    },
    {
        "label": "GifWindow",
        "kind": 6,
        "importPath": "FINAL.MAIN",
        "description": "FINAL.MAIN",
        "peekOfCode": "class GifWindow(QtWidgets.QWidget):\n    def __init__(self):\n        super().__init__()\n        # Set window properties\n        self.setWindowTitle(\"Come to the world of automation\")\n        self.setGeometry(150, 150, 800, 600)\n        # Remove the maximize option\n        self.setWindowFlags(self.windowFlags() & ~QtCore.Qt.WindowMaximizeButtonHint)\n        # Set background color\n        self.setStyleSheet(\"background-color: black;\")",
        "detail": "FINAL.MAIN",
        "documentation": {}
    },
    {
        "label": "NextWindow",
        "kind": 6,
        "importPath": "FINAL.MAIN",
        "description": "FINAL.MAIN",
        "peekOfCode": "class NextWindow(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n        # Your existing initialization code...\n        # Create an instance of Assistant\n        self.assistant_instance = test.Assistant()\n        # Start the assistant\n        self.assistant_instance.run_assistant()\n        # Set window properties (larger window size)\n        self.setWindowTitle(\"Next Window\")",
        "detail": "FINAL.MAIN",
        "documentation": {}
    },
    {
        "label": "speak",
        "kind": 2,
        "importPath": "FINAL.MAIN",
        "description": "FINAL.MAIN",
        "peekOfCode": "def speak(audio):\n    assistant.say(audio)\n    print(f\": {audio}\")\n    assistant.runAndWait()\nclass GifLoaderWorker(QtCore.QThread):\n    gif_path_loaded = QtCore.pyqtSignal(str)  # Signal to emit when a GIF path is loaded\n    def __init__(self, gif_paths):\n        super().__init__()\n        self.gif_paths = gif_paths\n    def run(self):",
        "detail": "FINAL.MAIN",
        "documentation": {}
    },
    {
        "label": "assistant",
        "kind": 5,
        "importPath": "FINAL.MAIN",
        "description": "FINAL.MAIN",
        "peekOfCode": "assistant = pyttsx3.init('sapi5')\nvoices = assistant.getProperty('voices')\nassistant.setProperty('voice', voices[1].id)\nassistant.setProperty('rate', 150)\ndef speak(audio):\n    assistant.say(audio)\n    print(f\": {audio}\")\n    assistant.runAndWait()\nclass GifLoaderWorker(QtCore.QThread):\n    gif_path_loaded = QtCore.pyqtSignal(str)  # Signal to emit when a GIF path is loaded",
        "detail": "FINAL.MAIN",
        "documentation": {}
    },
    {
        "label": "voices",
        "kind": 5,
        "importPath": "FINAL.MAIN",
        "description": "FINAL.MAIN",
        "peekOfCode": "voices = assistant.getProperty('voices')\nassistant.setProperty('voice', voices[1].id)\nassistant.setProperty('rate', 150)\ndef speak(audio):\n    assistant.say(audio)\n    print(f\": {audio}\")\n    assistant.runAndWait()\nclass GifLoaderWorker(QtCore.QThread):\n    gif_path_loaded = QtCore.pyqtSignal(str)  # Signal to emit when a GIF path is loaded\n    def __init__(self, gif_paths):",
        "detail": "FINAL.MAIN",
        "documentation": {}
    },
    {
        "label": "model_path",
        "kind": 5,
        "importPath": "FINAL.mBERT",
        "description": "FINAL.mBERT",
        "peekOfCode": "model_path = \"FINAL\\\\Models\\\\vosk-model-en-in-0.5\"\ntry:\n    model = Model(model_path)\n    print(\"Model loaded successfully!\")\nexcept Exception as e:\n    print(\"Error:\", e)",
        "detail": "FINAL.mBERT",
        "documentation": {}
    },
    {
        "label": "speak",
        "kind": 2,
        "importPath": "FINAL.nasa",
        "description": "FINAL.nasa",
        "peekOfCode": "def speak(audio):\n    print(\"    \")\n    assistant.say(audio)\n    print(f\":{audio}\")\n    assistant.runAndWait()\ndef takecommand():\n    command = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening..........\")\n        command.pause_threshold = 1",
        "detail": "FINAL.nasa",
        "documentation": {}
    },
    {
        "label": "takecommand",
        "kind": 2,
        "importPath": "FINAL.nasa",
        "description": "FINAL.nasa",
        "peekOfCode": "def takecommand():\n    command = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening..........\")\n        command.pause_threshold = 1\n        audio = command.listen(source)\n        try : \n            print(\"Recognising...\")\n            querry = command.recognize_google(audio,language=\"en-in\")\n            print(f'You said : {querry}')",
        "detail": "FINAL.nasa",
        "documentation": {}
    },
    {
        "label": "nasanews",
        "kind": 2,
        "importPath": "FINAL.nasa",
        "description": "FINAL.nasa",
        "peekOfCode": "def nasanews(date):\n    apikey = \"4qay02XQL1ADxneyqbFiSOQsFrbqrJlfJUlCg8bc\"\n    url = \"https://api.nasa.gov/planetary/apod?api_key=\" + apikey\n    params_ = {\"date\":str(date)}\n    r = requests.get(url,params=params_ )\n    data = r.json()\n    print(data)\n    info = data[\"explanation\"]\n    title = data['title']\n    image = data['url']",
        "detail": "FINAL.nasa",
        "documentation": {}
    },
    {
        "label": "assistant",
        "kind": 5,
        "importPath": "FINAL.nasa",
        "description": "FINAL.nasa",
        "peekOfCode": "assistant = pyttsx3.init('sapi5')\nvoices = assistant.getProperty('voices')\nassistant.setProperty('voices',voices[0].id)\nassistant.setProperty('rate',150)\ndef speak(audio):\n    print(\"    \")\n    assistant.say(audio)\n    print(f\":{audio}\")\n    assistant.runAndWait()\ndef takecommand():",
        "detail": "FINAL.nasa",
        "documentation": {}
    },
    {
        "label": "voices",
        "kind": 5,
        "importPath": "FINAL.nasa",
        "description": "FINAL.nasa",
        "peekOfCode": "voices = assistant.getProperty('voices')\nassistant.setProperty('voices',voices[0].id)\nassistant.setProperty('rate',150)\ndef speak(audio):\n    print(\"    \")\n    assistant.say(audio)\n    print(f\":{audio}\")\n    assistant.runAndWait()\ndef takecommand():\n    command = sr.Recognizer()",
        "detail": "FINAL.nasa",
        "documentation": {}
    },
    {
        "label": "speak",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def speak(audio):\n    assistant.say(audio)\n    print(f\": {audio}\")\n    assistant.runAndWait()\n# Optimized take command function (name requirement removed)\ndef takecommand():\n    command = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        command.pause_threshold = 0.8",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "takecommand",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def takecommand():\n    command = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        command.pause_threshold = 0.8\n        command.energy_threshold = 300  \n        while True:\n            try:\n                audio = command.listen(source, timeout=5, phrase_time_limit=8)\n                print(\"Recognizing...\")",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "ask_question",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def ask_question(query):\n    speak(\"What would you like to ask?\")\n    question = query  # Take question from the user's input\n    context = \"I am your personal assistant. I can help you with various tasks and answer your questions.\"  # Provide context if needed\n    result = question_answerer(question=question, context=context)\n    answer = result['answer']\n    speak(answer)\n# Get user name at startup\ndef get_user_name():\n    speak(\"Hello, what would you like to call me?\")",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "get_user_name",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def get_user_name():\n    speak(\"Hello, what would you like to call me?\")\n    global user_name\n    user_name = takecommand().split()[0]\n    speak(f\"Nice to meet you, {user_name}. You can call me by saying my name first.\")\n# Delayed imports for on-demand functionality\ndef import_modules():\n    global wikipedia\n    import wikipedia\n# Run this in a separate thread to import the modules in the background",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "import_modules",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def import_modules():\n    global wikipedia\n    import wikipedia\n# Run this in a separate thread to import the modules in the background\ndef background_module_import():\n    threading.Thread(target=import_modules).start()\n# Get weather information\ndef get_weather():\n    speak(\"Tell me your city\")\n    city = takecommand()",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "background_module_import",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def background_module_import():\n    threading.Thread(target=import_modules).start()\n# Get weather information\ndef get_weather():\n    speak(\"Tell me your city\")\n    city = takecommand()\n    api_key = \"2a52eb44477d710bab5b4734ef32344b\"  # Replace with your actual OpenWeatherMap API key\n    weather_url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n    try:\n        response = requests.get(weather_url)",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def get_weather():\n    speak(\"Tell me your city\")\n    city = takecommand()\n    api_key = \"2a52eb44477d710bab5b4734ef32344b\"  # Replace with your actual OpenWeatherMap API key\n    weather_url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n    try:\n        response = requests.get(weather_url)\n        data = response.json()\n        if data[\"cod\"] != \"404\":\n            main = data['main']",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "get_location",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def get_location():\n    try:\n        response = requests.get(\"http://ip-api.com/json/\")\n        data = response.json()\n        city = data['city']\n        country = data['country']\n        speak(f\"You are currently in {city}, {country}.\")\n    except Exception as e:\n        speak(\"Unable to determine your location.\")\n# Google Search",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "google_search",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def google_search(query):\n    speak(f\"Searching Google for {query}.\")\n    webbrowser.open(f\"https://www.google.com/search?q={query}\")\n# Wikipedia Search\ndef wikipedia_search(query):\n    speak(f\"Searching Wikipedia for {query}.\")\n    try:\n        summary = wikipedia.summary(query, sentences=2)\n        speak(\"According to Wikipedia\")\n        speak(summary)",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "wikipedia_search",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def wikipedia_search(query):\n    speak(f\"Searching Wikipedia for {query}.\")\n    try:\n        summary = wikipedia.summary(query, sentences=2)\n        speak(\"According to Wikipedia\")\n        speak(summary)\n    except wikipedia.exceptions.PageError:\n        speak(\"Sorry, I couldn't find anything on Wikipedia for that.\")\n    except wikipedia.exceptions.DisambiguationError as e:\n        speak(f\"Your query is too ambiguous. Did you mean: {e.options[:5]}?\")",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "youtube_search",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def youtube_search(query):\n    speak(f\"Searching YouTube for {query}.\")\n    webbrowser.open(f\"https://www.youtube.com/results?search_query={query}\")\n# System control functions for shutdown and restart\ndef system_control(command):\n    if 'shut down' in command:\n        speak(\"Shutting down the system.\")\n        os.system(\"shutdown /s /t 1\")\n    elif 'restart' in command:\n        speak(\"Restarting the system.\")",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "system_control",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def system_control(command):\n    if 'shut down' in command:\n        speak(\"Shutting down the system.\")\n        os.system(\"shutdown /s /t 1\")\n    elif 'restart' in command:\n        speak(\"Restarting the system.\")\n        os.system(\"shutdown /r /t 1\")\n# Set reminder function\ndef set_reminder():\n    speak(\"What do you want to be reminded about?\")",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "set_reminder",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def set_reminder():\n    speak(\"What do you want to be reminded about?\")\n    reminder = takecommand()\n    speak(\"In how many minutes?\")\n    minutes = int(takecommand())\n    future_time = datetime.datetime.now() + datetime.timedelta(minutes=minutes)\n    speak(f\"Reminder set for {minutes} minutes from now.\")\n    threading.Timer(minutes * 60, lambda: speak(f\"Reminder: {reminder}\")).start()\n# Efficient news function\ndef get_news():",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "get_news",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def get_news():\n    try:\n        speak(\"Fetching the latest news...\")\n        api_key = \"028c9fc91fd04dd99d86ba3db42db83d\"  # Replace with your actual news API key\n        url = f\"https://newsapi.org/v2/top-headlines?country=in&apiKey={api_key}\"\n        response = requests.get(url).json()\n        for i, article in enumerate(response[\"articles\"][:5]):\n            speak(f\"News {i + 1}: {article['title']}\")\n    except Exception as e:\n        speak(\"Unable to fetch news at the moment.\")",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "send_email",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def send_email():\n    speak(\"What is the subject of the email?\")\n    subject = takecommand()\n    speak(\"What should I say in the email?\")\n    body = takecommand()\n    email_content = f\"Subject: {subject}\\n\\n{body}\"\n    try:\n        server = smtplib.SMTP('smtp.gmail.com', 587)\n        server.starttls()\n        server.login('aroraratan77@gmail.com', 'ratan2007')  # Replace with actual credentials",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "run_assistant",
        "kind": 2,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "def run_assistant():\n    get_user_name()  # Get user name at startup\n    background_module_import()  # Imports modules in the background\n    while True:\n        query = takecommand()\n        if query == \"none\":\n            continue\n        if 'weather' in query:\n            get_weather()\n        elif 'location' in query:",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "assistant",
        "kind": 5,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "assistant = pyttsx3.init('sapi5')\nvoices = assistant.getProperty('voices')\nassistant.setProperty('voice', voices[1].id)\nassistant.setProperty('rate', 150)\n# Function to speak out loud\ndef speak(audio):\n    assistant.say(audio)\n    print(f\": {audio}\")\n    assistant.runAndWait()\n# Optimized take command function (name requirement removed)",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "voices",
        "kind": 5,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "voices = assistant.getProperty('voices')\nassistant.setProperty('voice', voices[1].id)\nassistant.setProperty('rate', 150)\n# Function to speak out loud\ndef speak(audio):\n    assistant.say(audio)\n    print(f\": {audio}\")\n    assistant.runAndWait()\n# Optimized take command function (name requirement removed)\ndef takecommand():",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "question_answerer",
        "kind": 5,
        "importPath": "FINAL.old",
        "description": "FINAL.old",
        "peekOfCode": "question_answerer = pipeline(\"question-answering\", model=\"distilbert-base-uncased-distilled-squad\")\n# Ask question function using Hugging Face\ndef ask_question(query):\n    speak(\"What would you like to ask?\")\n    question = query  # Take question from the user's input\n    context = \"I am your personal assistant. I can help you with various tasks and answer your questions.\"  # Provide context if needed\n    result = question_answerer(question=question, context=context)\n    answer = result['answer']\n    speak(answer)\n# Get user name at startup",
        "detail": "FINAL.old",
        "documentation": {}
    },
    {
        "label": "MainWindow",
        "kind": 6,
        "importPath": "FINAL.ui",
        "description": "FINAL.ui",
        "peekOfCode": "class MainWindow(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        # Set the title and size of the window\n        self.setWindowTitle(\"Personal Assistant\")\n        self.setGeometry(200, 200, 800, 600)  # x, y, width, height\n        # Initialize UI\n        self.initUI()\n        # Set up a timer to change outline color every 300 milliseconds\n        self.timer = QTimer(self)",
        "detail": "FINAL.ui",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "FINAL.ui",
        "description": "FINAL.ui",
        "peekOfCode": "app = QApplication(sys.argv)\nwindow = MainWindow()\nwindow.show()\nsys.exit(app.exec_())",
        "detail": "FINAL.ui",
        "documentation": {}
    },
    {
        "label": "window",
        "kind": 5,
        "importPath": "FINAL.ui",
        "description": "FINAL.ui",
        "peekOfCode": "window = MainWindow()\nwindow.show()\nsys.exit(app.exec_())",
        "detail": "FINAL.ui",
        "documentation": {}
    },
    {
        "label": "sendmessage",
        "kind": 2,
        "importPath": "FINAL.what",
        "description": "FINAL.what",
        "peekOfCode": "def sendmessage(recip_no, message):\n    try:\n        pywhatkit.sendwhatmsg_instantly(recip_no , message)\n        (recip_no, message)\n        print(\"Message sent successfully!\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\ndef messageinput1(list_no):\n    # Collect inputs from the user\n    name = input(\"Enter the name of the recipient: \")",
        "detail": "FINAL.what",
        "documentation": {}
    },
    {
        "label": "messageinput1",
        "kind": 2,
        "importPath": "FINAL.what",
        "description": "FINAL.what",
        "peekOfCode": "def messageinput1(list_no):\n    # Collect inputs from the user\n    name = input(\"Enter the name of the recipient: \")\n    recip_no = str(list_no)\n    message = input(\"Enter the message: \")\n    sendmessage(recip_no, message)\ndef messageinput(list_no):        \n    message = input(\"Enter the message: \")\n    for i in range(len(list_no)):  # Corrected loop\n        # Collect inputs from the user",
        "detail": "FINAL.what",
        "documentation": {}
    },
    {
        "label": "messageinput",
        "kind": 2,
        "importPath": "FINAL.what",
        "description": "FINAL.what",
        "peekOfCode": "def messageinput(list_no):        \n    message = input(\"Enter the message: \")\n    for i in range(len(list_no)):  # Corrected loop\n        # Collect inputs from the user\n        name = input(\"Enter the name of the recipient: \")\n        recip_no = str(list_no[i])\n        sendmessage(recip_no, message)\nno = int(input(\"Enter number of contacts ::\"))\nif no > 1:\n    list_no = input(\"Enter the numbers and separate by commas (e.g. +XXXXXXXXXX, +XXXXXXXXXX) :: \").split(',')",
        "detail": "FINAL.what",
        "documentation": {}
    },
    {
        "label": "no",
        "kind": 5,
        "importPath": "FINAL.what",
        "description": "FINAL.what",
        "peekOfCode": "no = int(input(\"Enter number of contacts ::\"))\nif no > 1:\n    list_no = input(\"Enter the numbers and separate by commas (e.g. +XXXXXXXXXX, +XXXXXXXXXX) :: \").split(',')\n    messageinput(list_no)\nelse:\n    list_no = [input(\"Enter the number:: \")]\n    messageinput1(list_no)\nprint(list_no)",
        "detail": "FINAL.what",
        "documentation": {}
    },
    {
        "label": "send_desktop_message",
        "kind": 2,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "def send_desktop_message(recipient_name, message):\n    try:\n        # Open WhatsApp Desktop (adjust the path based on your system)\n        os.startfile(\"C:\\\\Users\\\\arora\\\\OneDrive\\\\Desktop\\\\WhatsApp - Shortcut.lnk\")\n        time.sleep(5)  # Wait for the app to open\n        # Focus on the search bar and type the recipient's name\n        pyautogui.hotkey('ctrl', 'f')  # Shortcut to open search\n        time.sleep(1)\n        pyautogui.typewrite(recipient_name, interval=0.1)\n        time.sleep(2)",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    },
    {
        "label": "on_send_click",
        "kind": 2,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "def on_send_click():\n    recipient_name = entry_name.get()\n    message = entry_message.get()\n    if recipient_name and message:\n        send_desktop_message(recipient_name, message)\n    else:\n        messagebox.showwarning(\"Input Error\", \"Please fill in both fields.\")\n# Add a send button\nsend_button = tk.Button(root, text=\"Send Message\", command=on_send_click)\nsend_button.pack(pady=20)",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "root = tk.Tk()\nroot.title(\"WhatsApp Message Sender\")\n# Set the window size\nroot.geometry(\"400x250\")\n# Add a label and entry for the recipient's name\nlabel_name = tk.Label(root, text=\"Recipient's Name:\")\nlabel_name.pack(pady=10)\nentry_name = tk.Entry(root, width=30)\nentry_name.pack(pady=5)\n# Add a label and entry for the message",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    },
    {
        "label": "label_name",
        "kind": 5,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "label_name = tk.Label(root, text=\"Recipient's Name:\")\nlabel_name.pack(pady=10)\nentry_name = tk.Entry(root, width=30)\nentry_name.pack(pady=5)\n# Add a label and entry for the message\nlabel_message = tk.Label(root, text=\"Message:\")\nlabel_message.pack(pady=10)\nentry_message = tk.Entry(root, width=30)\nentry_message.pack(pady=5)\n# Function to handle button click",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    },
    {
        "label": "entry_name",
        "kind": 5,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "entry_name = tk.Entry(root, width=30)\nentry_name.pack(pady=5)\n# Add a label and entry for the message\nlabel_message = tk.Label(root, text=\"Message:\")\nlabel_message.pack(pady=10)\nentry_message = tk.Entry(root, width=30)\nentry_message.pack(pady=5)\n# Function to handle button click\ndef on_send_click():\n    recipient_name = entry_name.get()",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    },
    {
        "label": "label_message",
        "kind": 5,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "label_message = tk.Label(root, text=\"Message:\")\nlabel_message.pack(pady=10)\nentry_message = tk.Entry(root, width=30)\nentry_message.pack(pady=5)\n# Function to handle button click\ndef on_send_click():\n    recipient_name = entry_name.get()\n    message = entry_message.get()\n    if recipient_name and message:\n        send_desktop_message(recipient_name, message)",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    },
    {
        "label": "entry_message",
        "kind": 5,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "entry_message = tk.Entry(root, width=30)\nentry_message.pack(pady=5)\n# Function to handle button click\ndef on_send_click():\n    recipient_name = entry_name.get()\n    message = entry_message.get()\n    if recipient_name and message:\n        send_desktop_message(recipient_name, message)\n    else:\n        messagebox.showwarning(\"Input Error\", \"Please fill in both fields.\")",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    },
    {
        "label": "send_button",
        "kind": 5,
        "importPath": "FINAL.whatsappdesktop",
        "description": "FINAL.whatsappdesktop",
        "peekOfCode": "send_button = tk.Button(root, text=\"Send Message\", command=on_send_click)\nsend_button.pack(pady=20)\n# Run the main loop\nroot.mainloop()",
        "detail": "FINAL.whatsappdesktop",
        "documentation": {}
    }
]